[Mysql]常用的笔记
一、创建表之后生成的一些文件的作用：
	FRM文件：存放表结构
	myd文件：存放数据
	myi文件：存放索引
二、Mysql中一些常用的语句
	创建单值索引的语句：
		create index 索引的名称 on 表名(字段名)
		alter table 表名 add index 索引的名称 (字段名)
	删除索引的语句：
		drop index 索引的名称 on 表名
		alter table 表名 drop index 索引的名称
	查看某个表上的索引：
		show index from 表名
		show keys from 表名
三、Mysql的小笔记
	Sql语句的书写的顺序：
		SELECT DISTINCT <SELECT_LIST>
		FROM <LFET_TABLE> <JOIN_TYPE> JOIN
		RIGHT <RIGHT_TABLE> ON <JOIN_CONDITION>
		WHERE <WHERE_CONDITION>
		GROUP BY <GROUP_LIST>
		HAVING <HAVING_CONDITION>
		ORDER BY <ORDER_BY_CONDITION>
		LIMIT <LIMIT_NUMBER>

		where和having的区别：
			where字句的作用是在对结果进行分组前过滤数据
			having字句的作用是筛选满足条件的组，即在分组之后进行数据的过滤，使用having条件过滤的是特定的组
	Sql语句机器读取的顺序：
		FROM <LEFT_TABLE> ON <JOIN_CONDITION>
		<JOIN_TYPE> JOIN <RIGHT_TABLE>
		WHERE <WHERE_CONDITION>
		GROUP BY <GROUP_BY_LIST>
		HAVING <HAVING_CONDITION>
		SELECT DISTINCT <SELECT_LIST>
		ORDER BY <ORDER_BY_CONDITION>
		LIMIT <LIMIT_NUMBER>
	Group By字句对SELECT指定的字段的限制：
		在SELECT指定的字段要么就包含在Group By语句的后面作为分组的依据；要么就放在Sql语句支持的聚合函数中。但是Myql对Group By语句进行了改进，它可以存在不满足上述规则的语句的存在进行查询，此时Mysql会默认在查询语句的后面加上limit 1操作，这样返回的只有一条数据，此时返回的数据有可能跟需要的数据不符。
	各种各样的Join语句：
		LEFT JOIN：
			SELECT * FROM A LEFT JOIN B ON A.ID = B.ID [查出的结果是A的独有+A和B的共有]
		RIGHT JOIN：
			SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID [查出的结果是B的独有+A和B的共有]
		INNER JOIN
			SELECT * FROM A INNER JOIN B ON A.ID = B.ID [查出的结果是A和B的共有]
		单独取出A：
			SELECT * FROM A LEFT JOIN B ON A.ID = B.ID WHERE B.ID IS NULL [取出A的独有]
		单独取出B：
			SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID WHERE A.ID IS NULL [取出B的独有]
		取出所有数据并且去重：
			SELECT * FROM A LEFT JON B ON A.ID = B.ID 
			UNION
			SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID
		取出除A和B共有的数据：
			SELECT * FROM A LEFT JOIN B ON A.ID = B.ID WHERE B.ID IS NULL
			UNION
			SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID WHERE A.ID IS NULL
	索引：
		索引[Index]是帮助Mysql高效获取的数据结构[索引本身是一种数据结构]
		优势：
			提高数据的检索效率，降低IO
			本身对数据进行了排序，降低数据的排序成本，降低CPU消耗
		劣势：
			索引的构建也需要占用空间
			会降低数据表更新的速度
			需要花时间去进行数据库索引的优化
	使用Explain查看Sql的执行计划：
四、MYSQL的一些常用命令和一些概念
	创建数据库
		CREATE DATABASE + 数据库名 + DEFAULT CHARACTER SET UTF8
	展示有哪些数据库
		SHOW DATABASES
	选择数据库
		USER + 数据库名
	删除数据库
		DROP DATABASE + 数据库名
	存储引擎：决定了表的类型，即如何存储和和索引数据、是否支持事务等。
	查看数据库支持的引擎
		SHOW ENGINES\G
		其中\G用于纵向的展示结果数据
	查询默认的存储引擎
		SHOW VARIABLES LIKE "%storage_engine%"
	数据类型：决定存储数据的类型。MYSQL数据库管理系统提供了整形类型、浮点类型、定点数类型和位类型、日期和时间类型、字符串类型。
	整数类型
		MYSQL数据库除了支持所有整数类型(SMALLINT和INT)外，还进行了相应的扩展，扩展后增加了TINYINT、MEDIUMINT和BIGINT这三个整数类型。
		TINYINT：1个字节
		SMALLINT：2个字节
		MEDIUMINT：3个字节
		INT和INTEGER：4个字节
		BIGINT：5个字节
	浮点数类型、定点数类型和位类型
		FLOAT：4个字节
		DOUBLE：8个字节
		普通情况下可以选择FLOAT或者DOUBLE，当需要精确到小数点10为以上，就需要选择DOUBLE类型
		DEC(M,D)和DECIMAL(M,D)：M+2个字节
		BIT(M)：M个字节
	日期和时间类型
		DATE：4个字节
		DATETIME：8个字节
		TIMESTAMP：4个字节
		TIME：3个字节
		YEAR：1个字节
		表示年月日：DATE
		表示年月日时分秒：DATETIME
		如果经常需要插入或者更新为系统当前时间，一般用TIMESTAMP
		表示时分秒：TIME
		年份：YEAR
	字符串类型
		CHAR(M)：M个字节
		VARCHAR(M)：M个字节
		CHAR最大只能装载M个字节，且无论其中的数据能否占据到M个字节，在存储的时候都会占据M个字节；如果是VARCHAR，同样的，它的最大长度也是M个字节，但是它能根据数据的长度的不同占据不同的字节数。
五、表的操作
	创建表
		创建表的语句
			CREATE TABLE 表名 (
				属性名 数据类型，
				属性名 数据类型，
				..
				属性名 数据类型
			)
		查看表结构
			DESCRIBE + 表名：查看表定义
			SHOW CREATE TABLE + 表名：查看表的详细定义
		删除表
			DROP TABLE + 表名
		修改表
			修改表名：
				ALTER TABLE + 旧表名 + RENAME [TO] + 新表名
			增加表的字段：
				在表的最后一个位置增加字段
					ALTER TABLE + 表名 +  ADD + 属性名 + 属性类型
				在表的第一个位置增加字段[使用FIRST关键字]
					ALTER TABLE + 表名 + ADD + 属性名 + 属性类型 + FIRST
				在表的指定字段之后增加
					ALTER TABLE + 表名 + ADD + 属性名 + 属性类型 + AFTER + 属性名
			删除字段：
				ALTER TABLE + 表名 + DROP + 属性名
			修改字段：
				修改字段的数据类型
					ALTER TABLE + 表名 + MODIFY + 属性名 + 属性类型
				修改字段的名字
					ALTER TABLE + 表名 + CHANGE + 旧属性名 + 新属性名 + 旧属性类型
				同时修改字段的名字和属性
					ALTER TABEL + 表名 + CHANGE + 旧属性名 + 新属性名 + 新属性类型
				修改字段的顺序
					ALTER TABLE + 表名 + MODIFY + 属性名1 + 数据类型 + BEFORE|AFTER + 属性名2
		操作表的约束
			对于已经创建好的表，虽然字段的数据类型决定了所能存储的数据类型，但是表中所存储的数据是否合法并没有进行检查
			MYSQL所支持的完整性约束：
				NOT NULL：约束字段的值不能为空
					语法形式：
						CREATE TABLE + 表名 (
							属性名 属性类型 NOT NULL，
							...
						)
				DEFAULT：设置字段的默认值
					语法形式：
						CREATE TABLE + 表名 (
							属性名 属性类型 DEFAULT 默认值，
							...
						)
				UNIQUE KEY(UK)：约束字段的值唯一
					语法形式：
						CREATE TABLE + 表名 (
							属性名 属性类型 UNIQUE，
							...
						)
				PRIMARY KEY(PK)：约束字段为主键
					单字段主键语法：
						CREATE TABLE + 表名 (
							属性名 属性类型 PRIMARY KEY，
							...
						)
					多字段主键语法：
						CREATE TABLE + 表名 (
							属性名 属性类型，
							...
							PRIMARY KEY(属性名1, 属性名2...)
						)
				AUTO_INCREMENT：约束字段的值自增[MYSQL唯一扩展的约束]
					语法形式：
						CREATE TABLE + 表名 (
							属性名 属性类型 AUTO_INCREMEMT
						)
				FOREIGN KEY(FK)：约束字段为表的外键
					在具体设置FK约束时，设置FK约束的字段必须依赖于数据库中已经存在的父表的主键，同时外键可以设置为NULL
					语法形式：
						CREATE TABLE + 表名(
							属性名 属性类型，
							属性名 属性类型，
							...
							FOREIGN KET(属性名1) REFERENCES 另一个表名(属性名2)
						)
六、索引的操作
	数据库对象索引其实与书的目录非常相似，主要是为了提高从表中检索数据的速度。由于数据存储在数据库表中，所以索引是创建在数据库表对象上的，由表中的一个字段或多个字段生成的键组成，这些键存储在数据结构(B-树或哈希表)中，INNODB和MYISAM存储引擎支持BTREE类型的索引，MEMORY存储引擎支持HASH索引，默认使用的是BTREE索引。
	MSQYL支持6种索引
		普通索引：就是在创建索引时，不附加任何限制条件(唯一、非空等限制)，该类型的索引可以创建在任何数据类型的字段上。
			创建表时创建索引：
				CREATE TABLE + 表名 (
					属性名 属性类型，
					属性名 属性类型，
					...
					INDEX|KEY 索引名(属性名1 ASC|DESC)
				)
			在已经存在的表上创建普通索引：
				CREATE INDEX + 索引名 + ON 表名(属性名 ASC|DESC)
			通过ALTER TABLE的SQL语句创建普通索引：
				ALTER TABLE + 表名 + ADD INDEX|KEY + 索引名(属性名 ASC|DESC)
		唯一索引：就是在创建索引的时，限制索引的值必须是唯一的。在MYSQL中，根据创建索引方式，可以分为自动索引和手动索引两种。所谓自动索引，是指在数据库表里设置完整性约束时，该表会被系统自动的创建索引；所谓手动索引，是指手动在表上创建索引。
			创建表时创建唯一索引：
				CREATE TABLE + 表名 (
					属性名 属性类型，
					属性名 属性类型，
					...
					UNIQUE INDEX|KEY 索引名(属性名1 ASC|DESC)
				)
			在已经存在的表上创建唯一索引：
				CREATE UNIQUE INDEX 索引名 ON 表名(属性名 ASC|DESC)
			通过ALTER TABLE的SQL语句创建唯一索引：
				ALTER TABLE 表名 ADD UNIQUE INDEX|KEY 索引名(属性名 ASC|DESC)
		全文索引：全文索引主要关联在数据类型为CHAR、VARCHAR和TEXT的字段上，以便能够更加快速地查询数据量较大的字符串类型的字段。
			创建表时创建全文索引：
				CREATE TABLE + 表名 (
					属性名 属性类型，
					属性名 属性类型，
					...
					FULLTEXT INDEX|KEY 索引名(属性名1 ASC|DESC)
				)
			在已经存在的表上创建全文索引：
				CREATE FULLTEXT INDEX 索引名 ON 表名(属性名 ASC|DESC)
			通过ALTER TABLE的SQL语句创建全文索引：
				ALTER TABLE 表名 ADD FULLTEXT INDEX|KET 索引名(属性名 ASC|DESC)
		单列索引
		多列索引：指在创建索引时，所关联的字段不是一个字段，而是多个字段，虽然可以通过所关联的字段进行查询，但是只有查询条件中使用了关联字段中的第一个字段，多列索引才会被使用。
			创建表时创建多值索引：
				CREATE TABLE + 表名 (
					属性名 属性类型，
					属性名 属性类型，
					...
					INDEX|KEY 索引名(属性名1 ASC|DESC, 属性名2 ASC|DESC...)
				)
			在已经存在的表上创建多列索引：
				CREATE INDEX 索引名 ON 表名(属性名1 ASC|DESC, 属性名2 ASC|DESC...)
			通过ALTER TABLE的SQL语句创建多列索引：
				ALTER TABLE 表名 ADD INDEX 索引名(属性名1 ASC|DESC, 属性名2 ASC|DESC...)
		空间索引
	以下情况适合创建索引：
		经常被查询的字段，即在WHRER字句中出现的字段
		在分组的字段，即在GROUP BY出现的字段
		存在依赖关系的子表和父表之间的联合查询，即主键或外键字段
		设置唯一完整性约束的字段
	以下情况不适合创建索引：
		在查询中很少被使用的字段
		拥有很多重复值的字段
	删除索引
		语法形式：
			DROP INDEX 索引名 ON 表名
	查看索引
		语法形式：
			SHOW INDEX FOMR 表名
七、视图的操作
	为了提高复杂SQL语句的复用性和表操作的安全性，MYSQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚表，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。
	视图的特点
		视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系
		视图是由基本表产生的虚表
		视图的建立和删除不影响基本表
		视图内容的更新直接影响基本表
		当视图来自多个基本表时，不允许添加和删除数据
	创建视图
		语法形式：
			CREATE VIEW 视图名 AS 查询语句
	使用视图的方式
		SELECT * FROM 视图名
	创建各种视图
		由于视图的功能实际上就是封装查询语句，那么是不是任何形式的查询语句都可以封装在视图里？
		封装实现查询常量语句的视图，即常量视图
			CREATE VIEW 视图名 AS SELECT 常量
		封装使用聚合函数(SUM, MIN, MAX, COUNT等)查询语句的视图
			CREATE VIEW 视图名 AS SELECT COUNT(列名) FROM 表名
		封装实现排序功能(ORDER BY)查询语句的视图
			CREATE VIEW 视图名 AS SELECT 列名 FROM 表名 ORDER BY 列名
		封装实现了表内连接查询语句的视图
			CREATE VIEW 视图名 AS SELECT 列名 FROM 表名1, 表名2 WHERE 条件
		封装实现了表外链接查询语句的视图
			CREATE VIEW 视图名 AS SELECT 列名 FROM 表名1 LEFT|RIGHT JOIN 表名2 ON 条件
		封装子查询相关查询语句的视图
			CREATE VIEW 视图名 AS SELECT 列名 FROM 表名1 WHERE 表名1.字段 = (SELECT 字段 FROM 表名2)
		封装实现联合查询(UNION UNION ALL)查询语句的视图
			CREATE VIEW 视图名 AS SELECT 列名 FROM 表名1 UNION|UNION ALL SELECT 列名 FROM 表名2
	查看视图
		SHOW TABLES：不仅可以查看表的名字，还可以显示视图的名字
		SHOW TABLE STATUS：不仅会显示表的详细信息，同时也会显示视图的详细信息
		SHOW CREATE VIEW 视图名：查看视图定义信息
		DESCRIBE|DESC：查看视图设计信息
	删除视图
		语法形式：
			DROP VIEW 视图名1, 视图名2...
	修改视图
		对于已经创建好的视图，当使用一段时间之后，就会需要进行一些结构上的修改，即视图的修改操作。对于已经创建好的表，尤其是已经有大量数据的表，通过先删除，然后再按照新的表定义重建表的方式来修改表，需要做许多额外的工作，但是视图则没有这么多麻烦，视图相当于虚表，并没有存储数据，所以完全可以通过删除之后重建的方式。
		鉴于删除重建视图比较麻烦，MYSQL提供了可以实现替换的创建视图语法，重建视图的语法形式：
			CREATE OR REPLACE VIEW 视图名 AS 查询语句
			ALTER VIEW 视图名 AS 查询语句
	利用视图操作基本表
		检索数据：通过视图查询数据与通过表查询数据完全相同，只不过通过视图查询比表更安全、更简单、实用。
			语法形式：SELECT * FRPM 视图名
		利用视图操作基本表数据：由于视图中的数据就是虚表，因此对视图数据进行的更新操作，实际上是对其基本表数据进行更新操作，在具体更新视图数据时，需要注意以下两点：
			对视图数据进行添加、更新和删除操作直接影响基本表
			视图来自多个基本表时，不允许添加和删除数据

